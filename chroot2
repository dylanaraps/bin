#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>

int chrooted = 0;

void check_error(char *hint) {
    if (errno) {
        char *chroot_string = "not chrooted";

        if (chrooted)
            chroot_string = "chrooted";

        printf("%s (%s): %s\n", hint, chroot_string, strerror(errno));
        exit(EXIT_FAILURE);
    }
}

void show_help_dialogue() {
    printf("%s\n", "uchroot - User chroot.\n"
            "Usage: uchroot [new root] [shell path]\n"
            "uchroot must have the setuid bit enabled for users on the file "
            "and must be owned by the root user to work properly.\n\n"
            "If new root is not provided, uchroot will fail.\n"
            "If shell path is not provided, /bin/bash is used.\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char **argv) {
    char *directory = "/";
    char *shell = "/bin/bash";

    /* Command-line parser here */
    if (argc >= 3) {
        // Really primitive parsing, but who cares
        if (argv[1])
            directory = argv[1];
        else
            show_help_dialogue();

        if (argv[2])
            shell = argv[2];
    } else
        show_help_dialogue();

    struct stat stat_struct;
    stat(directory, &stat_struct);
    check_error(directory);

    if (!S_ISDIR(stat_struct.st_mode)) {
        printf("%s: %s\n", directory, "Not a directory.");
        return EXIT_FAILURE;
    }

    /* chroot here */
    chroot(directory);
    check_error("chroot()");
    chrooted = 1; // Helps with user error debugging

    /* drop permissions here */
    setegid(getgid());
    check_error("setegid()");

    seteuid(getuid());
    check_error("seteuid()");

    stat(shell, &stat_struct);
    check_error(shell);

    if (!S_ISREG(stat_struct.st_mode)) {
        printf("%s: %s\n", shell, "Not a file.");
        return EXIT_FAILURE;
    }

    access(shell, X_OK); // S_ISREG implies our F_OK
    check_error(shell);

    /* All of the above succeeded, it's shell time boys */
    int process = fork();
    check_error("fork()");

    if (process == 0)
        execl(shell, (char *)NULL);

    waitpid(process, NULL, 0);
    // system() is deemed insecure, sad boy hours
    // TODO: support passing arguments to shell lol

    return EXIT_SUCCESS;
}
